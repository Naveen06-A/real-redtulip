import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import moment from 'moment';
import logo from '../assets/logo.png';

// Function overloads for better type safety
export function generatePdf(
  title: string,
  head: string[][],
  body: (string | number)[][],
  fileName: string,
  outputType: 'blob',
  summaryData?: (string | number)[][]
): Promise<Blob>;
export function generatePdf(
  title: string,
  head: string[][],
  body: (string | number)[][],
  fileName: string,
  outputType: 'datauristring',
  summaryData?: (string | number)[][]
): Promise<string>;
export function generatePdf(
  title: string,
  head: string[][],
  body: (string | number)[][],
  fileName: string,
  outputType: 'save',
  summaryData?: (string | number)[][]
): Promise<void>;
export async function generatePdf(
  title: string,
  head: string[][],
  body: (string | number)[][],
  fileName: string,
  outputType: 'datauristring' | 'blob' | 'save' = 'blob',
  summaryData?: (string | number)[][]
): Promise<string | Blob | void> {
  try {
    // Input validation
    if (!title || typeof title !== 'string') {
      throw new Error('Invalid title: Must be a non-empty string');
    }
    if (!Array.isArray(head) || !head.every(row => Array.isArray(row) && row.every(cell => typeof cell === 'string'))) {
      throw new Error('Invalid headers: Must be an array of arrays of strings');
    }
    if (!Array.isArray(body) || !body.every(row => Array.isArray(row))) {
      throw new Error('Invalid body: Must be an array of arrays');
    }
    if (!fileName || typeof fileName !== 'string') {
      throw new Error('Invalid fileName: Must be a non-empty string');
    }
    if (outputType !== 'datauristring' && outputType !== 'blob' && outputType !== 'save') {
      throw new Error(`Invalid output type: Must be 'datauristring', 'blob', or 'save', got '${outputType}'`);
    }
    if (summaryData && (!Array.isArray(summaryData) || !summaryData.every(row => Array.isArray(row)))) {
      throw new Error('Invalid summaryData: Must be an array of arrays');
    }

    console.debug('Generating PDF with inputs:', {
      title,
      headers: head,
      bodySample: body.slice(0, 2),
      totalRows: body.length,
      fileName,
      outputType,
      hasSummaryData: !!summaryData,
      summaryDataSample: summaryData?.slice(0, 2),
    });

    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });

    // Define page dimensions and margins
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 15;
    const maxWidth = pageWidth - 2 * margin; // 180mm

    // Define blue color (Tailwind blue-600)
    const primaryColor = [37, 99, 235]; // #2563eb in RGB

    // Function to add header
    const addHeader = () => {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(16);
      doc.setTextColor(...primaryColor);
      doc.text(title, margin, 20);
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      doc.setTextColor(100);
      doc.text(`Generated on: ${moment().format('MMMM Do YYYY, h:mm:ss a')}`, margin, 28);
      doc.text('Generated by RedTulip Property Management', margin, 34);
    };

    // Function to add footer
    const addFooter = (pageNumber: number) => {
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
      doc.setTextColor(100);
      doc.text('Generated by RedTulip Property Management', margin, pageHeight - 10);
      const totalPages = doc.internal.getNumberOfPages();
      doc.text(`Page ${pageNumber} of ${totalPages}`, pageWidth - margin - 30, pageHeight - 10);
    };

    // Page 1: Cover and Summary
    addHeader();

    // Add logo if available
    let logoHeight = 0;
    try {
      const img = new Image();
      img.src = logo;
      await new Promise((resolve, reject) => {
        img.onload = () => resolve(true);
        img.onerror = () => reject(new Error('Failed to load logo image'));
        setTimeout(() => reject(new Error('Logo image loading timed out')), 5000);
      });
      doc.addImage(img, 'PNG', margin, 40, 50, 15);
      logoHeight = 20;
    } catch (error) {
      console.warn('Logo loading failed:', error);
      doc.setFontSize(12);
      doc.setTextColor(100);
      doc.text('Logo not available', margin, 50);
      logoHeight = 15;
    }

    // Summary Section
    if (summaryData && summaryData.length > 0) {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(14);
      doc.setTextColor(...primaryColor);
      doc.text('Summary', margin, 40 + logoHeight + 10);

      autoTable(doc, {
        body: summaryData,
        startY: 40 + logoHeight + 15,
        theme: 'striped',
        headStyles: {
          fillColor: primaryColor,
          textColor: [255, 255, 255],
          fontSize: 10,
          fontStyle: 'bold',
        },
        bodyStyles: {
          fontSize: 9,
          textColor: [50, 50, 50],
          cellPadding: 1.5,
        },
        columnStyles: {
          0: { cellWidth: 55, fontStyle: 'bold', halign: 'left' },
          1: { cellWidth: maxWidth - 55, halign: 'left' },
        },
        margin: { left: margin, right: margin },
        styles: { overflow: 'linebreak', font: 'helvetica' },
        didDrawPage: (data) => {
          addHeader();
          addFooter(1);
        },
      });
    }

    // Page 2: Detailed Table
    doc.addPage();
    addHeader();
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.setTextColor(...primaryColor);
    doc.text('Detailed Progress', margin, 40);

    autoTable(doc, {
      head,
      body: body.map(row => row.map(cell => String(cell || 'N/A'))),
      startY: 45,
      theme: 'striped',
      headStyles: {
        fillColor: primaryColor,
        textColor: [255, 255, 255],
        fontSize: 10,
        fontStyle: 'bold',
        halign: 'center',
      },
      bodyStyles: {
        fontSize: 9,
        textColor: [50, 50, 50],
        cellPadding: 1.5,
      },
      columnStyles: {
        0: { cellWidth: 22, halign: 'left' }, // Suburb
        1: { cellWidth: 22, halign: 'left' }, // Date Range
        2: { cellWidth: 22, halign: 'left' }, // Street Name
        3: { cellWidth: 18, halign: 'left' }, // Activity Type
        4: { cellWidth: 14, halign: 'right' }, // Completed
        5: { cellWidth: 14, halign: 'right' }, // Target
        6: { cellWidth: 14, halign: 'right' }, // Progress (%)
        7: { cellWidth: 18, halign: 'right' }, // Desktop Appraisals
        8: { cellWidth: 18, halign: 'right' }, // F2F Appraisals
        9: { cellWidth: 23, halign: 'left' }, // Reason
      },
      margin: { top: 45, left: margin, right: margin },
      styles: { overflow: 'linebreak', font: 'helvetica' },
      didDrawPage: (data) => {
        addHeader();
        addFooter(data.pageNumber);
      },
    });

    // Output based on type
    if (outputType === 'save') {
      doc.save(fileName);
      return;
    } else if (outputType === 'datauristring') {
      const result = doc.output('datauristring');
      if (typeof result !== 'string' || !result.startsWith('data:application/pdf;base64,')) {
        const blob = doc.output('blob') as Blob;
        return await new Promise<string>((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result as string);
          reader.onerror = () => reject(new Error('Failed to convert blob to data URL'));
          reader.readAsDataURL(blob);
        });
      }
      return result;
    } else {
      return doc.output('blob') as Blob;
    }
  } catch (error: any) {
    console.error('Error generating PDF:', {
      message: error.message,
      stack: error.stack,
      title,
      headersSample: head.slice(0, 2),
      bodySample: body.slice(0, 2),
      summaryDataSample: summaryData?.slice(0, 2),
      outputType,
    });
    throw error;
  }
}